<!DOCTYPE html>
<html>
  <head>
    <title>Random City Generator</title>
    <style>
      #cityCanvas {
        border: 1px solid #000;
      }
    </style>
  </head>
  <body>
    <canvas id="cityCanvas" width="800" height="500"></canvas>

    <script>
      const canvas = document.getElementById('cityCanvas');
      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;

      // Function to generate a random number within a range
      function getRandomNumber(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      // Function to generate a random city
      function generateCity(cityLength, cityHeight, minBuildingHeight, maxBuildingHeight, subwayHeight, minBuildingWidth, maxBuildingWidth, minBuildingDistance, maxBuildingDistance) {
        // Array to store the city layout
        var buildings = [];

        // Put the road in the middle
        const roadPosition = cityHeight - subwayHeight - 1

        const buildingQueue = []

        // Prepare building width dimensions
        let position = 0
        for (; position < cityLength; position += getRandomNumber(minBuildingDistance, maxBuildingDistance)) {
          // Generate a random building width
          let width = getRandomNumber(minBuildingWidth, maxBuildingWidth)

          if (width % 2 === 1) {
            // Don't allow odd number building widths, this makes elevator generation easier
            width += 1
          }

          if (position + width > cityLength) {
            // The next buidling size is out of bounds of the city
            if (cityLength - position < minBuildingWidth ) {
              // stretch the last building to the end
              const building = buildingQueue[buildingQueue.length - 1]
              building[1] = cityLength - building[0]
              position = cityLength
            }
            break
          }

          // Add the building to the queue
          buildingQueue.push([position, width])
          position += width
        }

        if (position < cityLength) {
          // If there is a gap, fill it with a building
          buildingQueue.push([position, cityLength - position])
        }

        // Generate the road
        var road = {
          type: 'road',
          x: 0,
          y: roadPosition,
          width: cityLength,
          height: 1
        };
        buildings.push(road);

        // Generate the subway
        var subway = {
          type: 'subway',
          x: 0,
          y: roadPosition + 1,
          width: cityLength,
          height: subwayHeight
        };
        buildings.push(subway);

        const actualMaxBuildingHeight = maxBuildingHeight > cityHeight
          ? cityHeight
          : maxBuildingHeight

        // Generate the buildings
        for (const buildingData of buildingQueue) {
          const buildingHeight = getRandomNumber(minBuildingHeight, actualMaxBuildingHeight);
		      const x = buildingData[0]
          const buildingWidth = buildingData[1]

          const building = {
            type: 'building',
            x: x,
            y: roadPosition - buildingHeight,
            width: buildingWidth,
            height: buildingHeight,
            children: []
          };
          buildings.push(building);

          // Generate the elevator to the subway

          const elevator = {
            type: 'elevator',
            x: building.x + (buildingWidth / 2),
            y: roadPosition - buildingHeight,
            width: 1,
            height: buildingHeight + subwayHeight
          };
          building.children.push(elevator)

          for (let roomId = building.height - 3; roomId > 0; roomId -= 3) {
            const leftRoom = {
              type: 'leftRoom',
              x: building.x + 1,
              y: roadPosition - buildingHeight + roomId,
              width: buildingWidth / 2 - elevator.width ,
              height: 3
            };
            building.children.push(leftRoom)

            const rightRoom = {
              type: 'rightRoom',
              x: elevator.x + elevator.width,
              y: roadPosition - buildingHeight + roomId,
              width: buildingWidth / 2 - elevator.width - 1,
              height: 3
            };
            building.children.push(rightRoom)
          }
        }

        return buildings;
      }

      /**
       * 
       */
      function drawRect(ctx, features, pixelPerUnit) {
        for (const shape of features) {
          let offsetHeight = 0

          switch (shape.type) {
            case 'road':
              ctx.fillStyle = '#242629';
              break;
            case 'building':
              ctx.fillStyle = '#5B6A7A';
              break;
            case 'elevator':
              ctx.fillStyle = '#F8DF9D';
              break;
            case 'subway':
              ctx.fillStyle = '#903642';
              break;
            case 'leftRoom':
            case 'rightRoom':
              ctx.fillStyle = '#BDAFEE';
              offsetHeight = 1
              break;
            
          }

          ctx.fillRect(
            shape.x * pixelPerUnit,
            shape.y * pixelPerUnit + offsetHeight,
            shape.width * pixelPerUnit,
            shape.height * pixelPerUnit - offsetHeight 
          );

          if (shape.children !== undefined) {
            drawRect(ctx, shape.children, pixelPerUnit)
          }
        }
      }

      /**
       * Draw the city layout on the canvas
       */
      function drawBuildings(buildings, pixelPerUnit) {
        var ctx = canvas.getContext('2d');

        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);

        // Define the gradient colors
        gradient.addColorStop(0, 'rgb(64, 0, 64)');        // Dark purple
        gradient.addColorStop(0.5, 'rgb(255, 102, 0)');    // Sunset blaze
        gradient.addColorStop(1, 'rgb(255, 204, 153)');    // Light orange

        // Fill the canvas with the gradient
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawRect(ctx, buildings, pixelPerUnit)        
      }

      // Example usage
      const metersPerUnit = 1
      const pixelPerUnit = 3
      const cityLength = canvasWidth / pixelPerUnit
      const cityHeight = canvasHeight / pixelPerUnit
      const minBuildingHeight = 100;
      const maxBuildingHeight = 120;
      const minBuildingWidth = 15
      const maxBuildingWidth = 20
      const minBuildingDistance = 0
      const maxBuildingDistance = 5
      const subwayHeight = 6;
      

      document.addEventListener('DOMContentLoaded', function() {
        var city = generateCity(cityLength, cityHeight, minBuildingHeight, maxBuildingHeight, subwayHeight, minBuildingWidth, maxBuildingWidth, minBuildingDistance, maxBuildingDistance);
        drawBuildings(city, pixelPerUnit);
      });
    </script>
  </body>
</html>

